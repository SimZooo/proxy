
/*
async fn parse_sni(stream: &TcpStream) -> Option<String> {
    let mut buf = [0u8; 2048];
    let n = match stream.peek(&mut buf).await {
        Ok(n) => n,
        Err(e) => { eprintln!("{e}"); return None; }
    };
    
    let client_hello_res = parse_tls_plaintext(&mut buf);

    let ch = match client_hello_res {
        Ok((_, ch)) => {
            ch
        },
        Err(e) => {
            eprintln!("Failed to parse client hello: {e}");
            return None;
        }
    };

    let mut sni = None;

    if let Some(TlsMessage::Handshake(message)) = ch.msg.first() {
        let TlsMessageHandshake::ClientHello(hello) = message else { return None };

        let Some(extensions) = hello.ext else {
            return None
        };
        let (_, ext) = match parse_tls_extension(extensions) {
            Ok(exts) => exts,
            Err(e) => { eprintln!("Failed to parse TLS extensions"); return None }
        };
        if let TlsExtension::SNI(sni_list) = ext {
            sni = sni_list.first().cloned();
        }
    }

    let Some((_, sni)) = sni else {
        eprintln!("Failed to get SNI");
        return None
    };

    let sni = match String::from_utf8(sni.to_vec()) {
        Ok(sni) => sni,
        Err(e) => { eprintln!("Failed to get SNI string: {e}"); return None }
    };

    Some(sni)
}

pub async fn handle_connection(mut stream: TcpStream, socket_addr: SocketAddr) {
    let Some(sni) = parse_sni(&stream).await else {
        eprintln!("Couldn't TLS SNI");
        return
    };
    println!("{}", sni);

    let mut root_cert_store = RootCertStore::empty();
    root_cert_store.extend(webpki_roots::TLS_SERVER_ROOTS.iter().cloned());
    let config = ClientConfig::builder()
        .with_root_certificates(root_cert_store)
        .with_no_client_auth();
    let connector = TlsConnector::from(Arc::new(config));
    let domain = match ServerName::try_from(sni) {
        Ok(d) => d,
        Err(e) => {
            eprintln!("Failed to create domain: {e}");
            return;
        }
    };

    let upstream = connector.connect(domain, stream);
}
*/